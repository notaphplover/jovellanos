{"version":3,"sources":["dist/js/bundle/node_modules/browser-pack/_prelude.js","dist/js/bundle/src/collection/token-map.ts","dist/js/bundle/src/main.ts","dist/js/bundle/src/task/flow/task-flow-when.ts","dist/js/bundle/src/task/flow/task-part-begin-constraint.ts","dist/js/bundle/src/task/flow/task-part-constraint.ts","dist/js/bundle/src/task/flow/task-part-end-constraint.ts","dist/js/bundle/src/task/flow/task-part-group-constraint.ts","dist/js/bundle/src/task/flow/task-part-time-constraint.ts","dist/js/bundle/src/task/operation/operation-manager.ts","dist/js/bundle/src/task/task-engine.ts","dist/js/bundle/src/task/task-part-when-events.ts","dist/js/bundle/src/task/task-part-when-operator.ts","dist/js/bundle/node_modules/@babel/runtime/helpers/assertThisInitialized.js","dist/js/bundle/node_modules/@babel/runtime/helpers/classCallCheck.js","dist/js/bundle/node_modules/@babel/runtime/helpers/createClass.js","dist/js/bundle/node_modules/@babel/runtime/helpers/getPrototypeOf.js","dist/js/bundle/node_modules/@babel/runtime/helpers/inherits.js","dist/js/bundle/node_modules/@babel/runtime/helpers/interopRequireDefault.js","dist/js/bundle/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","dist/js/bundle/node_modules/@babel/runtime/helpers/setPrototypeOf.js","dist/js/bundle/node_modules/@babel/runtime/helpers/typeof.js","dist/js/bundle/node_modules/events/events.js"],"names":[],"mappings":"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kB,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AAC7C,QAAA,UAAU,CAAC,YAAA;AACP,cAAI,UAAU,CAAC,KAAX,IAAoB,IAAxB,EAA8B;AAC1B,YAAA,OAAO;AACV,WAFD,MAEO;AACH,YAAA,IAAI,CAAC,kBAAL,CAAwB,UAAU,CAAC,KAAnC,EACK,IADL,CACU,OADV;AAEH;AACJ,SAPS,EAOP,UAAU,CAAC,MAPJ,CAAV;AAQH,OATM,CAAP;AAUH;;;;;;;;;;;;;;ACxTE,IAAM,qBAAqB,GAAG;AAIjC,EAAA,GAAG,EAAE,UAJ4B;AAQjC,EAAA,KAAK,EAAE;AAR0B,CAA9B;;;;;;;;;;ACAP,IAAY,oBAAZ;;;AAAA,CAAA,UAAY,oBAAZ,EAAgC;AAI5B,EAAA,oBAAA,CAAA,oBAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA;AAIA,EAAA,oBAAA,CAAA,oBAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAA;AACH,CATD,EAAY,oBAAoB,oCAApB,oBAAoB,GAAA,EAAA,CAAhC;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.dev.js","sourceRoot":"../../..","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","export class TokenMap<T> {\r\n    //#region Properties\r\n\r\n    /**\r\n     * Inner map.\r\n     */\r\n    protected innerMap: Map<number, T>;\r\n\r\n    /**\r\n     * List of unused indexed bellow the maximun used index.\r\n     */\r\n    protected unusedIndexes: number[];\r\n\r\n    //#endregion\r\n\r\n    public constructor() {\r\n        this.innerMap = new Map<number, T>();\r\n        this.unusedIndexes = new Array();\r\n    }\r\n\r\n    /**\r\n     * Adds an element to the array collection.\r\n     * @param elem Element to be added to the array.\r\n     * @returns index in which the element is located.\r\n     */\r\n    public add(elem: T): number {\r\n        if (0 === this.unusedIndexes.length) {\r\n            const lastIndex: number = this.innerMap.size;\r\n            this.innerMap.set(lastIndex, elem);\r\n            return lastIndex;\r\n        } else {\r\n            const lastIndex: number = this.unusedIndexes[this.unusedIndexes.length - 1];\r\n            --this.unusedIndexes.length;\r\n            this.innerMap.set(lastIndex, elem);\r\n            return lastIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains the amount of elements inside the array.\r\n     * @returns Amount of elements inside the array.\r\n     */\r\n    public count(): number {\r\n        return this.innerMap.size;\r\n    }\r\n\r\n    /**\r\n     * Iterates over the array and applies a function.\r\n     * @param consumer Function to apply to any pair of index-element found (undefined values are discarted).\r\n     */\r\n    public foreach(consumer: (value: T, key: number) => void): void {\r\n        this.innerMap.forEach(function(value: T, key: number) {\r\n            consumer(value, key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Obtains an element at the specified index.\r\n     * @param index Index of the element to obtaint.\r\n     * @returns Element obtianed at the specified index.\r\n     */\r\n    public get(index: number): T {\r\n        return this.innerMap.get(index);\r\n    }\r\n\r\n    /**\r\n     * Removes an element at the position specified.\r\n     * @param index Index of the element to be removed.\r\n     * @returns Result of the operation.\r\n     */\r\n    public remove(index: number): boolean {\r\n        if (this.innerMap.has(index)) {\r\n            this.innerMap.delete(index);\r\n            this.unusedIndexes[this.unusedIndexes.length] = index;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","import { TaskPartBeginConstraint } from './task/flow/task-part-begin-constraint';\nimport { TaskPartEndConstraint } from './task/flow/task-part-end-constraint';\nimport { TaskGroupConstraint } from './task/flow/task-part-group-constraint';\nimport { TaskTimeConstraint } from './task/flow/task-part-time-constraint';\nimport { OperationManager } from './task/operation/operation-manager';\nimport { TaskEngine } from './task/task-engine';\nimport { TASK_PART_WHEN_EVENTS } from './task/task-part-when-events';\nimport { TaskPartWhenOperator } from './task/task-part-when-operator';\n\nconst jovellanos = {\n    task: {\n        TASK_PART_WHEN_EVENTS: TASK_PART_WHEN_EVENTS,\n        TaskEngine: TaskEngine,\n        TaskPartWhenOperator: TaskPartWhenOperator,\n        flow: {\n            TaskGroupConstraint: TaskGroupConstraint,\n            TaskPartBeginConstraint: TaskPartBeginConstraint,\n            TaskPartEndConstraint: TaskPartEndConstraint,\n            TaskTimeConstraint: TaskTimeConstraint,\n        },\n        operation: {\n            OperationManager: OperationManager,\n        },\n    },\n};\n\nmodule.exports = jovellanos;\n","/**\r\n * Constraint that determines the start of the task part.\r\n */\r\nexport interface ITaskPartWhenConstraint {\r\n    /**\r\n     * When entity to check once this constraint is ensured.\r\n     */\r\n    after: ITaskPartWhenConstraint;\r\n    /**\r\n     * Type of this constraint.\r\n     */\r\n    constraintType: string;\r\n}\r\n\r\n/**\r\n * Constraint that determines the start of the task part.\r\n */\r\nexport abstract class TaskPartWhenConstraint implements ITaskPartWhenConstraint {\r\n    /**\r\n     * When entity to check once this constraint is ensured.\r\n     */\r\n    public after: ITaskPartWhenConstraint;\r\n    /**\r\n     * Type of this constraint.\r\n     */\r\n    public constraintType: string;\r\n\r\n    /**\r\n     * Creates a new task part constraint.\r\n     * @param after Constraint to apply after this constraint is checked.\r\n     * @param constraintType Constraint type.\r\n     */\r\n    public constructor(after: ITaskPartWhenConstraint, constraintType: string) {\r\n        this.after = after;\r\n        this.constraintType = constraintType;\r\n    }\r\n}\r\n","import { ITaskPartWhenConstraint } from './task-flow-when';\r\nimport {\r\n    TASK_CONSTRAINT_TYPES,\r\n    TaskPartConstraint,\r\n} from './task-part-constraint';\r\n\r\n/**\r\n * Represents a when constraint that is checked once a task part starts.\r\n */\r\nexport class TaskPartBeginConstraint extends TaskPartConstraint {\r\n    public constructor(after: ITaskPartWhenConstraint, alias: string) {\r\n        super(after, alias, TASK_CONSTRAINT_TYPES.START);\r\n    }\r\n}\r\n","import {\r\n    ITaskPartWhenConstraint,\r\n    TaskPartWhenConstraint,\r\n} from './task-flow-when';\r\n\r\n/**\r\n * Task constraint types\r\n */\r\nexport const TASK_CONSTRAINT_TYPES = {\r\n    /**\r\n     * Requires the end of a task part.\r\n     */\r\n    END: 'anim.end',\r\n    /**\r\n     * Requires a group of constraints.\r\n     */\r\n    GROUP: 'group',\r\n    /**\r\n     * Requires the start of a task part.\r\n     */\r\n    START : 'anim.start',\r\n    /**\r\n     * Requires an amount of time.\r\n     */\r\n    WAIT_FOR: 'wait',\r\n};\r\n\r\nexport abstract class TaskPartConstraint extends TaskPartWhenConstraint {\r\n    /**\r\n     * Alias of the part affected by this constraint.\r\n     */\r\n    public alias: string;\r\n\r\n    /**\r\n     * Creates a new task part constraint.\r\n     * @param after Constraint to apply after this constraint is checked.\r\n     * @param alias Aliases of the parts affected by this constraint.\r\n     * @param constraintType Constraint type.\r\n     */\r\n    public constructor(after: ITaskPartWhenConstraint, alias: string, constraintType: string) {\r\n        super(after, constraintType);\r\n\r\n        this.alias = alias;\r\n    }\r\n}\r\n","import { ITaskPartWhenConstraint } from './task-flow-when';\r\nimport {\r\n    TASK_CONSTRAINT_TYPES,\r\n    TaskPartConstraint,\r\n} from './task-part-constraint';\r\n\r\n/**\r\n * Represents a when constraint that is checked once a task part ends.\r\n */\r\nexport class TaskPartEndConstraint extends TaskPartConstraint {\r\n    public constructor(after: ITaskPartWhenConstraint, alias: string) {\r\n        super(after, alias, TASK_CONSTRAINT_TYPES.END);\r\n    }\r\n}\r\n","import { TaskPartWhenOperator } from '../task-part-when-operator';\r\nimport {\r\n    ITaskPartWhenConstraint,\r\n    TaskPartWhenConstraint,\r\n} from './task-flow-when';\r\nimport { TASK_CONSTRAINT_TYPES } from './task-part-constraint';\r\n\r\n/**\r\n * Represents a when constraint that is checked once a group of constraints are checked.\r\n */\r\nexport class TaskGroupConstraint extends TaskPartWhenConstraint {\r\n    /**\r\n     * Constraints to ensure\r\n     */\r\n    public constraints: ITaskPartWhenConstraint[];\r\n    /**\r\n     * Logical operator\r\n     */\r\n    public operator: TaskPartWhenOperator;\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     *\r\n     * @param after Constraint to check after all the constraitns of the group have successfully checked.\r\n     * @param constraints Group of constraints to check.\r\n     * @param operator Logical operator to apply.\r\n     */\r\n    public constructor(\r\n        after: ITaskPartWhenConstraint,\r\n        constraints: ITaskPartWhenConstraint[],\r\n        operator: TaskPartWhenOperator,\r\n    ) {\r\n        super(after, TASK_CONSTRAINT_TYPES.GROUP);\r\n\r\n        this.constraints = constraints;\r\n        this.operator = operator;\r\n    }\r\n}\r\n","import {\r\n    ITaskPartWhenConstraint,\r\n    TaskPartWhenConstraint,\r\n} from './task-flow-when';\r\nimport { TASK_CONSTRAINT_TYPES } from './task-part-constraint';\r\n\r\n/**\r\n * Represents a when constraint that is checked once an amount of time passes.\r\n */\r\nexport class TaskTimeConstraint extends TaskPartWhenConstraint {\r\n    /**\r\n     * Milliseconds to wait.\r\n     */\r\n    public millis: number;\r\n\r\n    public constructor(after: ITaskPartWhenConstraint, millis: number) {\r\n        super(after, TASK_CONSTRAINT_TYPES.WAIT_FOR);\r\n        this.millis = millis;\r\n    }\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { TokenMap } from '../../collection/token-map';\r\nimport { IOperationManagerAccess } from './operation-manager-access';\r\n\r\n/**\r\n * Operation arguments\r\n */\r\nexport interface IOperationArgs {\r\n    aliases: string[];\r\n}\r\n\r\n/**\r\n * Represents an operation manager. The operation is propagated using an event.\r\n * All the subscribers\r\n */\r\nexport class OperationManager<Args extends IOperationArgs> implements IOperationManagerAccess<Args> {\r\n\r\n    //#region Attributes\r\n\r\n    /**\r\n     * Function to be called to handle the event.\r\n     */\r\n    protected callFunction: (eventArgs: Args) => void;\r\n\r\n    /**\r\n     * Alias of the event.\r\n     */\r\n    protected eventAlias: string;\r\n\r\n    /**\r\n     * Event emmitter of the event.\r\n     */\r\n    protected eventEmitter: EventEmitter;\r\n\r\n    /**\r\n     * Object to storage all the functions subscribed.\r\n     */\r\n    protected subscriptionStorage: { [alias: string]: TokenMap<(eventArgs: Args) => void> };\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Creates a new operation manager\r\n     * @param eventAlias Event alias.\r\n     * @param eventEmitter Event emitter.\r\n     */\r\n    public constructor(eventAlias: string, eventEmitter: EventEmitter) {\r\n        const that = this;\r\n        this.callFunction = function(eventArgs: Args): void {\r\n            if (eventArgs.aliases == null) {\r\n                for (const alias in that.subscriptionStorage) {\r\n                    if (that.subscriptionStorage.hasOwnProperty(alias)) {\r\n                        const subscribers = that.subscriptionStorage[alias];\r\n                        if (subscribers != null) {\r\n                            subscribers.foreach(function(value: (eventArgs: Args) => void) {\r\n                                value(eventArgs);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                for (const alias of eventArgs.aliases) {\r\n                    const subscribers = that.subscriptionStorage[alias];\r\n                    if (subscribers != null) {\r\n                        subscribers.foreach(function(value: (eventArgs: Args) => void) {\r\n                            value(eventArgs);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this.eventAlias = eventAlias;\r\n        this.eventEmitter = eventEmitter;\r\n        this.subscriptionStorage = {};\r\n\r\n        this.eventEmitter.addListener(this.eventAlias, this.callFunction);\r\n    }\r\n\r\n    /**\r\n     * Disposes the instance.\r\n     */\r\n    public dispose(): void {\r\n        this.eventEmitter.removeListener(this.eventAlias, this.callFunction);\r\n    }\r\n\r\n    /**\r\n     * Substribes a handler under an alias.\r\n     * @param alias Alias of the handler.\r\n     * @param handler Handler to be subscribed.\r\n     */\r\n    public subscribe(alias: string, handler: (eventArgs: Args) => void): number {\r\n        if (null == this.subscriptionStorage[alias]) {\r\n            this.subscriptionStorage[alias] = new TokenMap();\r\n        }\r\n        return this.subscriptionStorage[alias].add(handler);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes a handler under an alias.\r\n     * @param alias Alias of the handler.\r\n     * @param index Index of the handler.\r\n     */\r\n    public unsubscribe(alias: string, index: number): boolean {\r\n        if (null == this.subscriptionStorage[alias]) {\r\n            return false;\r\n        } else {\r\n            return this.subscriptionStorage[alias].remove(index);\r\n        }\r\n    }\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { ITaskFlow } from './flow/task-flow';\r\nimport { ITaskFlowPart } from './flow/task-flow-part';\r\nimport {\r\n    ITaskFlowPartEndArgs,\r\n    ITaskFlowPartStartArgs,\r\n} from './flow/task-flow-part-event-args';\r\nimport { ITaskPartWhenConstraint } from './flow/task-flow-when';\r\nimport { TaskPartBeginConstraint } from './flow/task-part-begin-constraint';\r\nimport { TASK_CONSTRAINT_TYPES } from './flow/task-part-constraint';\r\nimport { TaskPartEndConstraint } from './flow/task-part-end-constraint';\r\nimport { TaskGroupConstraint } from './flow/task-part-group-constraint';\r\nimport { TaskTimeConstraint } from './flow/task-part-time-constraint';\r\nimport { OperationManager } from './operation/operation-manager';\r\nimport { IOperationManagerAccess } from './operation/operation-manager-access';\r\nimport { TASK_PART_WHEN_EVENTS } from './task-part-when-events';\r\nimport { TaskPartWhenOperator } from './task-part-when-operator';\r\n\r\n/**\r\n * Represents a task engine.\r\n */\r\nexport abstract class TaskEngine<TPart extends ITaskFlowPart> {\r\n    //#region Attributes\r\n\r\n    /**\r\n     * Task currently managed.\r\n     */\r\n    protected currentTask: ITaskFlow<TPart>;\r\n\r\n    /**\r\n     * Event emitter to use\r\n     */\r\n    protected eventEmitter: EventEmitter;\r\n\r\n    //#region Operations\r\n\r\n    /**\r\n     * Manager that handles the part end event.\r\n     */\r\n    protected partEndManager: OperationManager<ITaskFlowPartEndArgs<TPart>>;\r\n\r\n    /**\r\n     * Manager that handles the part start event.\r\n     */\r\n    protected partStartManager: OperationManager<ITaskFlowPartStartArgs<TPart>>;\r\n\r\n    //#endregion\r\n\r\n    //#endregion\r\n\r\n    //#region Public\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    public constructor() {\r\n        this.eventEmitter = new EventEmitter();\r\n\r\n        this.partEndManager = new OperationManager<ITaskFlowPartEndArgs<TPart>>(\r\n            TASK_PART_WHEN_EVENTS.END,\r\n            this.eventEmitter,\r\n        );\r\n        this.partStartManager = new OperationManager<ITaskFlowPartStartArgs<TPart>>(\r\n            TASK_PART_WHEN_EVENTS.START,\r\n            this.eventEmitter,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Obtains the access of the part end event.\r\n     * @returns Access of the part end event.\r\n     */\r\n    public getPartEndListenerAccess(): IOperationManagerAccess<ITaskFlowPartEndArgs<TPart>> {\r\n        const that = this;\r\n        return {\r\n            subscribe: function(\r\n                alias: string,\r\n                handler: (eventArgs: ITaskFlowPartEndArgs<TPart>) => void,\r\n            ): number {\r\n                return that.partEndManager.subscribe(alias, handler);\r\n            },\r\n            unsubscribe: function(alias: string, index: number): boolean {\r\n                return that.partEndManager.unsubscribe(alias, index);\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Obtains the access of the part start event.\r\n     * @returns Access of the part start event.\r\n     */\r\n    public getPartStartListenerAccess(): IOperationManagerAccess<ITaskFlowPartStartArgs<TPart>> {\r\n        const that = this;\r\n        return {\r\n            subscribe: function(\r\n                alias: string,\r\n                handler: (eventArgs: ITaskFlowPartStartArgs<TPart>) => void,\r\n            ): number {\r\n                return that.partStartManager.subscribe(alias, handler);\r\n            },\r\n            unsubscribe: function(alias: string, index: number): boolean {\r\n                return that.partStartManager.unsubscribe(alias, index);\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Handles a task flow.\r\n     * @param taskFlow Task flow to be managed.\r\n     * @returns Task part promises.\r\n     */\r\n    public handle(taskFlow: ITaskFlow<TPart>): Array<Promise<void>> {\r\n        if (taskFlow == null) {\r\n            throw new Error('It\\'s required a task flow.');\r\n        }\r\n        if (taskFlow.parts == null) {\r\n            throw new Error('It\\'s required a task flow with parts.');\r\n        }\r\n\r\n        this.currentTask = taskFlow;\r\n        const partPromises: Array<Promise<void>> = new Array(taskFlow.parts.length);\r\n\r\n        for (var i = 0; i < taskFlow.parts.length; ++i) {\r\n            partPromises[i] = this.handleTaskPart(taskFlow.parts[i]);\r\n        }\r\n\r\n        return partPromises;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Handles a task part.\r\n     *\r\n     * @param part Task part to handle.\r\n     *\r\n     * @returns Promise resolved once the part of the task is finished.\r\n     */\r\n    protected handleTaskPart(part: TPart): Promise<void> {\r\n        const that = this;\r\n\r\n        return new Promise<void>(function(resolve, reject) {\r\n            that.handleTaskPartWhen(part.when).then(function() {\r\n                // 1. Emit the start of task part.\r\n                that.eventEmitter.emit(\r\n                    TASK_PART_WHEN_EVENTS.START,\r\n                    {\r\n                        aliases: [part.alias],\r\n                        part: part,\r\n                    } as ITaskFlowPartStartArgs<TPart>,\r\n                );\r\n\r\n                const promise: PromiseLike<{} | void> = that.performTask(part);\r\n\r\n                promise.then(function() {\r\n                    // 3. Emit the end of the task part and resolve the promise.\r\n                    that.eventEmitter.emit(\r\n                        TASK_PART_WHEN_EVENTS.END,\r\n                        {\r\n                            aliases: [part.alias],\r\n                            part: part,\r\n                        } as ITaskFlowPartEndArgs<TPart>,\r\n                    );\r\n                    resolve();\r\n                });\r\n            }).catch(function(err: any) {\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Performs a task part.\r\n     * @param part Task part to be performed.\r\n     * @returns Promise resolved once the part task is performed.\r\n     */\r\n    protected abstract performTask(part: TPart): PromiseLike<{} | void>;\r\n\r\n    //#region TaskPartWhenconstraint\r\n\r\n    /**\r\n     * Handles the when entity of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     *\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhen(whenEntity: ITaskPartWhenConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            if (null == whenEntity) {\r\n                resolve();\r\n            } else {\r\n                switch (whenEntity.constraintType) {\r\n                    case TASK_CONSTRAINT_TYPES.START:\r\n                        that.handleTaskPartWhenPartBegins(whenEntity as TaskPartBeginConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    case TASK_CONSTRAINT_TYPES.END:\r\n                        that.handleTaskPartWhenPartEnds(whenEntity as TaskPartEndConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    case TASK_CONSTRAINT_TYPES.GROUP:\r\n                        that.handleTaskPartWhenPartGroup(whenEntity as TaskGroupConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    case TASK_CONSTRAINT_TYPES.WAIT_FOR:\r\n                        that.handleTaskPartWhenWaitFor(whenEntity as TaskTimeConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    default:\r\n                        reject(new Error('Unexpected when entity type.'));\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskPartBeginConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenPartBegins(whenEntity: TaskPartBeginConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            const eventHandler = function() {\r\n                that.partStartManager.unsubscribe(whenEntity.alias, token);\r\n                if (null == whenEntity.after) {\r\n                    resolve();\r\n                } else {\r\n                    that.handleTaskPartWhen(whenEntity.after)\r\n                        .then(resolve);\r\n                }\r\n            };\r\n            const token: number = that.partStartManager.subscribe(whenEntity.alias, eventHandler);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskPartEndConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenPartEnds(whenEntity: TaskPartEndConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            const eventHandler = function() {\r\n                that.partEndManager.unsubscribe(whenEntity.alias, token);\r\n                if (null == whenEntity.after) {\r\n                    resolve();\r\n                } else {\r\n                    that.handleTaskPartWhen(whenEntity.after)\r\n                        .then(resolve);\r\n                }\r\n            };\r\n            const token: number = that.partEndManager.subscribe(whenEntity.alias, eventHandler);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskGroupConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     *\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenPartGroup(whenEntity: TaskGroupConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            const childPromises: Array<Promise<void>> = new Array(whenEntity.constraints.length);\r\n\r\n            for (var i = 0; i < whenEntity.constraints.length; ++i) {\r\n                childPromises[i] = new Promise<void>(function(resolve, reject) {\r\n                    that.handleTaskPartWhen(whenEntity.constraints[i])\r\n                        .then(resolve);\r\n                });\r\n            }\r\n\r\n            if (TaskPartWhenOperator.AND === whenEntity.operator) {\r\n                Promise.all(childPromises)\r\n                    .then(function() {\r\n                        resolve();\r\n                    });\r\n            } else if (TaskPartWhenOperator.OR === whenEntity.operator) {\r\n                Promise.race(childPromises)\r\n                .then(function() {\r\n                    resolve();\r\n                });\r\n            } else {\r\n                reject('Unexpected operator.');\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskTimeConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     *\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenWaitFor(whenEntity: TaskTimeConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            setTimeout(function() {\r\n                if (whenEntity.after == null) {\r\n                    resolve();\r\n                } else {\r\n                    that.handleTaskPartWhen(whenEntity.after)\r\n                        .then(resolve);\r\n                }\r\n            }, whenEntity.millis);\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","/**\r\n * Prefixes used to ganerate alias for events over task parts.\r\n */\r\nexport const TASK_PART_WHEN_EVENTS = {\r\n    /**\r\n     * Prefix for any event raised once a task part is ended.\r\n     */\r\n    END: 'part.end',\r\n    /**\r\n     * Prefix for any event raised once a task part is started.\r\n     */\r\n    START: 'part.start',\r\n};\r\n","/**\r\n * Logical operator to apply.\r\n */\r\nexport enum TaskPartWhenOperator {\r\n    /**\r\n     * And operator.\r\n     */\r\n    AND,\r\n    /**\r\n     * Or operator.\r\n     */\r\n    OR,\r\n}\r\n","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY29sbGVjdGlvbi90b2tlbi1tYXAudHMiLCJzcmMvbWFpbi50cyIsInNyYy90YXNrL2Zsb3cvdGFzay1mbG93LXdoZW4udHMiLCJzcmMvdGFzay9mbG93L3Rhc2stcGFydC1iZWdpbi1jb25zdHJhaW50LnRzIiwic3JjL3Rhc2svZmxvdy90YXNrLXBhcnQtY29uc3RyYWludC50cyIsInNyYy90YXNrL2Zsb3cvdGFzay1wYXJ0LWVuZC1jb25zdHJhaW50LnRzIiwic3JjL3Rhc2svZmxvdy90YXNrLXBhcnQtZ3JvdXAtY29uc3RyYWludC50cyIsInNyYy90YXNrL2Zsb3cvdGFzay1wYXJ0LXRpbWUtY29uc3RyYWludC50cyIsInNyYy90YXNrL29wZXJhdGlvbi9vcGVyYXRpb24tbWFuYWdlci50cyIsInNyYy90YXNrL3Rhc2stZW5naW5lLnRzIiwic3JjL3Rhc2svdGFzay1wYXJ0LXdoZW4tZXZlbnRzLnRzIiwic3JjL3Rhc2svdGFzay1wYXJ0LXdoZW4tb3BlcmF0b3IudHMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztJQ0FhLFE7OztBQWVULHNCQUFBO0FBQUE7QUFDSSxTQUFLLFFBQUwsR0FBZ0IsSUFBSSxHQUFKLEVBQWhCO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLElBQUksS0FBSixFQUFyQjtBQUNIOzs7O3dCQU9VLEksRUFBTztBQUNkLFVBQUksTUFBTSxLQUFLLGFBQUwsQ0FBbUIsTUFBN0IsRUFBcUM7QUFDakMsWUFBTSxTQUFTLEdBQVcsS0FBSyxRQUFMLENBQWMsSUFBeEM7QUFDQSxhQUFLLFFBQUwsQ0FBYyxHQUFkLENBQWtCLFNBQWxCLEVBQTZCLElBQTdCO0FBQ0EsZUFBTyxTQUFQO0FBQ0gsT0FKRCxNQUlPO0FBQ0gsWUFBTSxVQUFTLEdBQVcsS0FBSyxhQUFMLENBQW1CLEtBQUssYUFBTCxDQUFtQixNQUFuQixHQUE0QixDQUEvQyxDQUExQjtBQUNBLFVBQUUsS0FBSyxhQUFMLENBQW1CLE1BQXJCO0FBQ0EsYUFBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixVQUFsQixFQUE2QixJQUE3QjtBQUNBLGVBQU8sVUFBUDtBQUNIO0FBQ0o7Ozs0QkFNVztBQUNSLGFBQU8sS0FBSyxRQUFMLENBQWMsSUFBckI7QUFDSDs7OzRCQU1jLFEsRUFBeUM7QUFDcEQsV0FBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixVQUFTLEtBQVQsRUFBbUIsR0FBbkIsRUFBOEI7QUFDaEQsUUFBQSxRQUFRLENBQUMsS0FBRCxFQUFRLEdBQVIsQ0FBUjtBQUNILE9BRkQ7QUFHSDs7O3dCQU9VLEssRUFBYTtBQUNwQixhQUFPLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsS0FBbEIsQ0FBUDtBQUNI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QUFBLG9CQUFBLENBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBQUEsS0FBQTtBQUlBLEVBQUEsb0JBQUEsQ0FBQSxvQkFBQSxDQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLElBQUE7QUFDSCxDQVRELEVBQVksb0JBQW9CLG9DQUFwQixvQkFBb0IsR0FBQSxFQUFBLENBQWhDOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJleHBvcnQgY2xhc3MgVG9rZW5NYXA8VD4ge1xyXG4gICAgLy8jcmVnaW9uIFByb3BlcnRpZXNcclxuXHJcbiAgICAvKipcclxuICAgICAqIElubmVyIG1hcC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGlubmVyTWFwOiBNYXA8bnVtYmVyLCBUPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3Qgb2YgdW51c2VkIGluZGV4ZWQgYmVsbG93IHRoZSBtYXhpbXVuIHVzZWQgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB1bnVzZWRJbmRleGVzOiBudW1iZXJbXTtcclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pbm5lck1hcCA9IG5ldyBNYXA8bnVtYmVyLCBUPigpO1xyXG4gICAgICAgIHRoaXMudW51c2VkSW5kZXhlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBhcnJheSBjb2xsZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byBiZSBhZGRlZCB0byB0aGUgYXJyYXkuXHJcbiAgICAgKiBAcmV0dXJucyBpbmRleCBpbiB3aGljaCB0aGUgZWxlbWVudCBpcyBsb2NhdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKGVsZW06IFQpOiBudW1iZXIge1xyXG4gICAgICAgIGlmICgwID09PSB0aGlzLnVudXNlZEluZGV4ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleDogbnVtYmVyID0gdGhpcy5pbm5lck1hcC5zaXplO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyTWFwLnNldChsYXN0SW5kZXgsIGVsZW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFzdEluZGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleDogbnVtYmVyID0gdGhpcy51bnVzZWRJbmRleGVzW3RoaXMudW51c2VkSW5kZXhlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgLS10aGlzLnVudXNlZEluZGV4ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyTWFwLnNldChsYXN0SW5kZXgsIGVsZW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFzdEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIGFtb3VudCBvZiBlbGVtZW50cyBpbnNpZGUgdGhlIGFycmF5LlxyXG4gICAgICogQHJldHVybnMgQW1vdW50IG9mIGVsZW1lbnRzIGluc2lkZSB0aGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyTWFwLnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBhcnJheSBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGNvbnN1bWVyIEZ1bmN0aW9uIHRvIGFwcGx5IHRvIGFueSBwYWlyIG9mIGluZGV4LWVsZW1lbnQgZm91bmQgKHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGRpc2NhcnRlZCkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmb3JlYWNoKGNvbnN1bWVyOiAodmFsdWU6IFQsIGtleTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pbm5lck1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlOiBULCBrZXk6IG51bWJlcikge1xyXG4gICAgICAgICAgICBjb25zdW1lcih2YWx1ZSwga2V5KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG9idGFpbnQuXHJcbiAgICAgKiBAcmV0dXJucyBFbGVtZW50IG9idGlhbmVkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoaW5kZXg6IG51bWJlcik6IFQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlubmVyTWFwLmdldChpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYXQgdGhlIHBvc2l0aW9uIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmUoaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLmlubmVyTWFwLmhhcyhpbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbm5lck1hcC5kZWxldGUoaW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLnVudXNlZEluZGV4ZXNbdGhpcy51bnVzZWRJbmRleGVzLmxlbmd0aF0gPSBpbmRleDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUYXNrUGFydEJlZ2luQ29uc3RyYWludCB9IGZyb20gJy4vdGFzay9mbG93L3Rhc2stcGFydC1iZWdpbi1jb25zdHJhaW50JztcbmltcG9ydCB7IFRhc2tQYXJ0RW5kQ29uc3RyYWludCB9IGZyb20gJy4vdGFzay9mbG93L3Rhc2stcGFydC1lbmQtY29uc3RyYWludCc7XG5pbXBvcnQgeyBUYXNrR3JvdXBDb25zdHJhaW50IH0gZnJvbSAnLi90YXNrL2Zsb3cvdGFzay1wYXJ0LWdyb3VwLWNvbnN0cmFpbnQnO1xuaW1wb3J0IHsgVGFza1RpbWVDb25zdHJhaW50IH0gZnJvbSAnLi90YXNrL2Zsb3cvdGFzay1wYXJ0LXRpbWUtY29uc3RyYWludCc7XG5pbXBvcnQgeyBPcGVyYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi90YXNrL29wZXJhdGlvbi9vcGVyYXRpb24tbWFuYWdlcic7XG5pbXBvcnQgeyBUYXNrRW5naW5lIH0gZnJvbSAnLi90YXNrL3Rhc2stZW5naW5lJztcbmltcG9ydCB7IFRBU0tfUEFSVF9XSEVOX0VWRU5UUyB9IGZyb20gJy4vdGFzay90YXNrLXBhcnQtd2hlbi1ldmVudHMnO1xuaW1wb3J0IHsgVGFza1BhcnRXaGVuT3BlcmF0b3IgfSBmcm9tICcuL3Rhc2svdGFzay1wYXJ0LXdoZW4tb3BlcmF0b3InO1xuXG5jb25zdCBqb3ZlbGxhbm9zID0ge1xuICAgIHRhc2s6IHtcbiAgICAgICAgVEFTS19QQVJUX1dIRU5fRVZFTlRTOiBUQVNLX1BBUlRfV0hFTl9FVkVOVFMsXG4gICAgICAgIFRhc2tFbmdpbmU6IFRhc2tFbmdpbmUsXG4gICAgICAgIFRhc2tQYXJ0V2hlbk9wZXJhdG9yOiBUYXNrUGFydFdoZW5PcGVyYXRvcixcbiAgICAgICAgZmxvdzoge1xuICAgICAgICAgICAgVGFza0dyb3VwQ29uc3RyYWludDogVGFza0dyb3VwQ29uc3RyYWludCxcbiAgICAgICAgICAgIFRhc2tQYXJ0QmVnaW5Db25zdHJhaW50OiBUYXNrUGFydEJlZ2luQ29uc3RyYWludCxcbiAgICAgICAgICAgIFRhc2tQYXJ0RW5kQ29uc3RyYWludDogVGFza1BhcnRFbmRDb25zdHJhaW50LFxuICAgICAgICAgICAgVGFza1RpbWVDb25zdHJhaW50OiBUYXNrVGltZUNvbnN0cmFpbnQsXG4gICAgICAgIH0sXG4gICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgT3BlcmF0aW9uTWFuYWdlcjogT3BlcmF0aW9uTWFuYWdlcixcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBqb3ZlbGxhbm9zO1xuIiwiLyoqXHJcbiAqIENvbnN0cmFpbnQgdGhhdCBkZXRlcm1pbmVzIHRoZSBzdGFydCBvZiB0aGUgdGFzayBwYXJ0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJVGFza1BhcnRXaGVuQ29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gZW50aXR5IHRvIGNoZWNrIG9uY2UgdGhpcyBjb25zdHJhaW50IGlzIGVuc3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFmdGVyOiBJVGFza1BhcnRXaGVuQ29uc3RyYWludDtcclxuICAgIC8qKlxyXG4gICAgICogVHlwZSBvZiB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cmFpbnRUeXBlOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJhaW50IHRoYXQgZGV0ZXJtaW5lcyB0aGUgc3RhcnQgb2YgdGhlIHRhc2sgcGFydC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUYXNrUGFydFdoZW5Db25zdHJhaW50IGltcGxlbWVudHMgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGVudGl0eSB0byBjaGVjayBvbmNlIHRoaXMgY29uc3RyYWludCBpcyBlbnN1cmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWZ0ZXI6IElUYXNrUGFydFdoZW5Db25zdHJhaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlIG9mIHRoaXMgY29uc3RyYWludC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cmFpbnRUeXBlOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhc2sgcGFydCBjb25zdHJhaW50LlxyXG4gICAgICogQHBhcmFtIGFmdGVyIENvbnN0cmFpbnQgdG8gYXBwbHkgYWZ0ZXIgdGhpcyBjb25zdHJhaW50IGlzIGNoZWNrZWQuXHJcbiAgICAgKiBAcGFyYW0gY29uc3RyYWludFR5cGUgQ29uc3RyYWludCB0eXBlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoYWZ0ZXI6IElUYXNrUGFydFdoZW5Db25zdHJhaW50LCBjb25zdHJhaW50VHlwZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5hZnRlciA9IGFmdGVyO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludFR5cGUgPSBjb25zdHJhaW50VHlwZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJVGFza1BhcnRXaGVuQ29uc3RyYWludCB9IGZyb20gJy4vdGFzay1mbG93LXdoZW4nO1xyXG5pbXBvcnQge1xyXG4gICAgVEFTS19DT05TVFJBSU5UX1RZUEVTLFxyXG4gICAgVGFza1BhcnRDb25zdHJhaW50LFxyXG59IGZyb20gJy4vdGFzay1wYXJ0LWNvbnN0cmFpbnQnO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSB3aGVuIGNvbnN0cmFpbnQgdGhhdCBpcyBjaGVja2VkIG9uY2UgYSB0YXNrIHBhcnQgc3RhcnRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRhc2tQYXJ0QmVnaW5Db25zdHJhaW50IGV4dGVuZHMgVGFza1BhcnRDb25zdHJhaW50IHtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihhZnRlcjogSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQsIGFsaWFzOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihhZnRlciwgYWxpYXMsIFRBU0tfQ09OU1RSQUlOVF9UWVBFUy5TVEFSVCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIElUYXNrUGFydFdoZW5Db25zdHJhaW50LFxyXG4gICAgVGFza1BhcnRXaGVuQ29uc3RyYWludCxcclxufSBmcm9tICcuL3Rhc2stZmxvdy13aGVuJztcclxuXHJcbi8qKlxyXG4gKiBUYXNrIGNvbnN0cmFpbnQgdHlwZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBUQVNLX0NPTlNUUkFJTlRfVFlQRVMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVzIHRoZSBlbmQgb2YgYSB0YXNrIHBhcnQuXHJcbiAgICAgKi9cclxuICAgIEVORDogJ2FuaW0uZW5kJyxcclxuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZXMgYSBncm91cCBvZiBjb25zdHJhaW50cy5cclxuICAgICAqL1xyXG4gICAgR1JPVVA6ICdncm91cCcsXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVzIHRoZSBzdGFydCBvZiBhIHRhc2sgcGFydC5cclxuICAgICAqL1xyXG4gICAgU1RBUlQgOiAnYW5pbS5zdGFydCcsXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVzIGFuIGFtb3VudCBvZiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBXQUlUX0ZPUjogJ3dhaXQnLFxyXG59O1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRhc2tQYXJ0Q29uc3RyYWludCBleHRlbmRzIFRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBvZiB0aGUgcGFydCBhZmZlY3RlZCBieSB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhbGlhczogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXNrIHBhcnQgY29uc3RyYWludC5cclxuICAgICAqIEBwYXJhbSBhZnRlciBDb25zdHJhaW50IHRvIGFwcGx5IGFmdGVyIHRoaXMgY29uc3RyYWludCBpcyBjaGVja2VkLlxyXG4gICAgICogQHBhcmFtIGFsaWFzIEFsaWFzZXMgb2YgdGhlIHBhcnRzIGFmZmVjdGVkIGJ5IHRoaXMgY29uc3RyYWludC5cclxuICAgICAqIEBwYXJhbSBjb25zdHJhaW50VHlwZSBDb25zdHJhaW50IHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihhZnRlcjogSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQsIGFsaWFzOiBzdHJpbmcsIGNvbnN0cmFpbnRUeXBlOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihhZnRlciwgY29uc3RyYWludFR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQgfSBmcm9tICcuL3Rhc2stZmxvdy13aGVuJztcclxuaW1wb3J0IHtcclxuICAgIFRBU0tfQ09OU1RSQUlOVF9UWVBFUyxcclxuICAgIFRhc2tQYXJ0Q29uc3RyYWludCxcclxufSBmcm9tICcuL3Rhc2stcGFydC1jb25zdHJhaW50JztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgd2hlbiBjb25zdHJhaW50IHRoYXQgaXMgY2hlY2tlZCBvbmNlIGEgdGFzayBwYXJ0IGVuZHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGFza1BhcnRFbmRDb25zdHJhaW50IGV4dGVuZHMgVGFza1BhcnRDb25zdHJhaW50IHtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihhZnRlcjogSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQsIGFsaWFzOiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihhZnRlciwgYWxpYXMsIFRBU0tfQ09OU1RSQUlOVF9UWVBFUy5FTkQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFRhc2tQYXJ0V2hlbk9wZXJhdG9yIH0gZnJvbSAnLi4vdGFzay1wYXJ0LXdoZW4tb3BlcmF0b3InO1xyXG5pbXBvcnQge1xyXG4gICAgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQsXHJcbiAgICBUYXNrUGFydFdoZW5Db25zdHJhaW50LFxyXG59IGZyb20gJy4vdGFzay1mbG93LXdoZW4nO1xyXG5pbXBvcnQgeyBUQVNLX0NPTlNUUkFJTlRfVFlQRVMgfSBmcm9tICcuL3Rhc2stcGFydC1jb25zdHJhaW50JztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgd2hlbiBjb25zdHJhaW50IHRoYXQgaXMgY2hlY2tlZCBvbmNlIGEgZ3JvdXAgb2YgY29uc3RyYWludHMgYXJlIGNoZWNrZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGFza0dyb3VwQ29uc3RyYWludCBleHRlbmRzIFRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJhaW50cyB0byBlbnN1cmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cmFpbnRzOiBJVGFza1BhcnRXaGVuQ29uc3RyYWludFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dpY2FsIG9wZXJhdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvcGVyYXRvcjogVGFza1BhcnRXaGVuT3BlcmF0b3I7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZnRlciBDb25zdHJhaW50IHRvIGNoZWNrIGFmdGVyIGFsbCB0aGUgY29uc3RyYWl0bnMgb2YgdGhlIGdyb3VwIGhhdmUgc3VjY2Vzc2Z1bGx5IGNoZWNrZWQuXHJcbiAgICAgKiBAcGFyYW0gY29uc3RyYWludHMgR3JvdXAgb2YgY29uc3RyYWludHMgdG8gY2hlY2suXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0b3IgTG9naWNhbCBvcGVyYXRvciB0byBhcHBseS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGFmdGVyOiBJVGFza1BhcnRXaGVuQ29uc3RyYWludCxcclxuICAgICAgICBjb25zdHJhaW50czogSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnRbXSxcclxuICAgICAgICBvcGVyYXRvcjogVGFza1BhcnRXaGVuT3BlcmF0b3IsXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihhZnRlciwgVEFTS19DT05TVFJBSU5UX1RZUEVTLkdST1VQKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQsXHJcbiAgICBUYXNrUGFydFdoZW5Db25zdHJhaW50LFxyXG59IGZyb20gJy4vdGFzay1mbG93LXdoZW4nO1xyXG5pbXBvcnQgeyBUQVNLX0NPTlNUUkFJTlRfVFlQRVMgfSBmcm9tICcuL3Rhc2stcGFydC1jb25zdHJhaW50JztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgd2hlbiBjb25zdHJhaW50IHRoYXQgaXMgY2hlY2tlZCBvbmNlIGFuIGFtb3VudCBvZiB0aW1lIHBhc3Nlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYXNrVGltZUNvbnN0cmFpbnQgZXh0ZW5kcyBUYXNrUGFydFdoZW5Db25zdHJhaW50IHtcclxuICAgIC8qKlxyXG4gICAgICogTWlsbGlzZWNvbmRzIHRvIHdhaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtaWxsaXM6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoYWZ0ZXI6IElUYXNrUGFydFdoZW5Db25zdHJhaW50LCBtaWxsaXM6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKGFmdGVyLCBUQVNLX0NPTlNUUkFJTlRfVFlQRVMuV0FJVF9GT1IpO1xyXG4gICAgICAgIHRoaXMubWlsbGlzID0gbWlsbGlzO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XHJcbmltcG9ydCB7IFRva2VuTWFwIH0gZnJvbSAnLi4vLi4vY29sbGVjdGlvbi90b2tlbi1tYXAnO1xyXG5pbXBvcnQgeyBJT3BlcmF0aW9uTWFuYWdlckFjY2VzcyB9IGZyb20gJy4vb3BlcmF0aW9uLW1hbmFnZXItYWNjZXNzJztcclxuXHJcbi8qKlxyXG4gKiBPcGVyYXRpb24gYXJndW1lbnRzXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElPcGVyYXRpb25BcmdzIHtcclxuICAgIGFsaWFzZXM6IHN0cmluZ1tdO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gbWFuYWdlci4gVGhlIG9wZXJhdGlvbiBpcyBwcm9wYWdhdGVkIHVzaW5nIGFuIGV2ZW50LlxyXG4gKiBBbGwgdGhlIHN1YnNjcmliZXJzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT3BlcmF0aW9uTWFuYWdlcjxBcmdzIGV4dGVuZHMgSU9wZXJhdGlvbkFyZ3M+IGltcGxlbWVudHMgSU9wZXJhdGlvbk1hbmFnZXJBY2Nlc3M8QXJncz4ge1xyXG5cclxuICAgIC8vI3JlZ2lvbiBBdHRyaWJ1dGVzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgdG8gaGFuZGxlIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNhbGxGdW5jdGlvbjogKGV2ZW50QXJnczogQXJncykgPT4gdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGV2ZW50QWxpYXM6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IGVtbWl0dGVyIG9mIHRoZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JqZWN0IHRvIHN0b3JhZ2UgYWxsIHRoZSBmdW5jdGlvbnMgc3Vic2NyaWJlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN1YnNjcmlwdGlvblN0b3JhZ2U6IHsgW2FsaWFzOiBzdHJpbmddOiBUb2tlbk1hcDwoZXZlbnRBcmdzOiBBcmdzKSA9PiB2b2lkPiB9O1xyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvcGVyYXRpb24gbWFuYWdlclxyXG4gICAgICogQHBhcmFtIGV2ZW50QWxpYXMgRXZlbnQgYWxpYXMuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRFbWl0dGVyIEV2ZW50IGVtaXR0ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihldmVudEFsaWFzOiBzdHJpbmcsIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyKSB7XHJcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbihldmVudEFyZ3M6IEFyZ3MpOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50QXJncy5hbGlhc2VzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgaW4gdGhhdC5zdWJzY3JpcHRpb25TdG9yYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc3Vic2NyaXB0aW9uU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGF0LnN1YnNjcmlwdGlvblN0b3JhZ2VbYWxpYXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yZWFjaChmdW5jdGlvbih2YWx1ZTogKGV2ZW50QXJnczogQXJncykgPT4gdm9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKGV2ZW50QXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgZXZlbnRBcmdzLmFsaWFzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoYXQuc3Vic2NyaXB0aW9uU3RvcmFnZVthbGlhc107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yZWFjaChmdW5jdGlvbih2YWx1ZTogKGV2ZW50QXJnczogQXJncykgPT4gdm9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUoZXZlbnRBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudEFsaWFzID0gZXZlbnRBbGlhcztcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0b3JhZ2UgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIodGhpcy5ldmVudEFsaWFzLCB0aGlzLmNhbGxGdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnRBbGlhcywgdGhpcy5jYWxsRnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic3RyaWJlcyBhIGhhbmRsZXIgdW5kZXIgYW4gYWxpYXMuXHJcbiAgICAgKiBAcGFyYW0gYWxpYXMgQWxpYXMgb2YgdGhlIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciBIYW5kbGVyIHRvIGJlIHN1YnNjcmliZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJzY3JpYmUoYWxpYXM6IHN0cmluZywgaGFuZGxlcjogKGV2ZW50QXJnczogQXJncykgPT4gdm9pZCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKG51bGwgPT0gdGhpcy5zdWJzY3JpcHRpb25TdG9yYWdlW2FsaWFzXSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0b3JhZ2VbYWxpYXNdID0gbmV3IFRva2VuTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvblN0b3JhZ2VbYWxpYXNdLmFkZChoYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyBhIGhhbmRsZXIgdW5kZXIgYW4gYWxpYXMuXHJcbiAgICAgKiBAcGFyYW0gYWxpYXMgQWxpYXMgb2YgdGhlIGhhbmRsZXIuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1bnN1YnNjcmliZShhbGlhczogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKG51bGwgPT0gdGhpcy5zdWJzY3JpcHRpb25TdG9yYWdlW2FsaWFzXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uU3RvcmFnZVthbGlhc10ucmVtb3ZlKGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IHsgSVRhc2tGbG93IH0gZnJvbSAnLi9mbG93L3Rhc2stZmxvdyc7XHJcbmltcG9ydCB7IElUYXNrRmxvd1BhcnQgfSBmcm9tICcuL2Zsb3cvdGFzay1mbG93LXBhcnQnO1xyXG5pbXBvcnQge1xyXG4gICAgSVRhc2tGbG93UGFydEVuZEFyZ3MsXHJcbiAgICBJVGFza0Zsb3dQYXJ0U3RhcnRBcmdzLFxyXG59IGZyb20gJy4vZmxvdy90YXNrLWZsb3ctcGFydC1ldmVudC1hcmdzJztcclxuaW1wb3J0IHsgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQgfSBmcm9tICcuL2Zsb3cvdGFzay1mbG93LXdoZW4nO1xyXG5pbXBvcnQgeyBUYXNrUGFydEJlZ2luQ29uc3RyYWludCB9IGZyb20gJy4vZmxvdy90YXNrLXBhcnQtYmVnaW4tY29uc3RyYWludCc7XHJcbmltcG9ydCB7IFRBU0tfQ09OU1RSQUlOVF9UWVBFUyB9IGZyb20gJy4vZmxvdy90YXNrLXBhcnQtY29uc3RyYWludCc7XHJcbmltcG9ydCB7IFRhc2tQYXJ0RW5kQ29uc3RyYWludCB9IGZyb20gJy4vZmxvdy90YXNrLXBhcnQtZW5kLWNvbnN0cmFpbnQnO1xyXG5pbXBvcnQgeyBUYXNrR3JvdXBDb25zdHJhaW50IH0gZnJvbSAnLi9mbG93L3Rhc2stcGFydC1ncm91cC1jb25zdHJhaW50JztcclxuaW1wb3J0IHsgVGFza1RpbWVDb25zdHJhaW50IH0gZnJvbSAnLi9mbG93L3Rhc2stcGFydC10aW1lLWNvbnN0cmFpbnQnO1xyXG5pbXBvcnQgeyBPcGVyYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi9vcGVyYXRpb24vb3BlcmF0aW9uLW1hbmFnZXInO1xyXG5pbXBvcnQgeyBJT3BlcmF0aW9uTWFuYWdlckFjY2VzcyB9IGZyb20gJy4vb3BlcmF0aW9uL29wZXJhdGlvbi1tYW5hZ2VyLWFjY2Vzcyc7XHJcbmltcG9ydCB7IFRBU0tfUEFSVF9XSEVOX0VWRU5UUyB9IGZyb20gJy4vdGFzay1wYXJ0LXdoZW4tZXZlbnRzJztcclxuaW1wb3J0IHsgVGFza1BhcnRXaGVuT3BlcmF0b3IgfSBmcm9tICcuL3Rhc2stcGFydC13aGVuLW9wZXJhdG9yJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgdGFzayBlbmdpbmUuXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFza0VuZ2luZTxUUGFydCBleHRlbmRzIElUYXNrRmxvd1BhcnQ+IHtcclxuICAgIC8vI3JlZ2lvbiBBdHRyaWJ1dGVzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYXNrIGN1cnJlbnRseSBtYW5hZ2VkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3VycmVudFRhc2s6IElUYXNrRmxvdzxUUGFydD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBlbWl0dGVyIHRvIHVzZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZXZlbnRFbWl0dGVyOiBFdmVudEVtaXR0ZXI7XHJcblxyXG4gICAgLy8jcmVnaW9uIE9wZXJhdGlvbnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hbmFnZXIgdGhhdCBoYW5kbGVzIHRoZSBwYXJ0IGVuZCBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcnRFbmRNYW5hZ2VyOiBPcGVyYXRpb25NYW5hZ2VyPElUYXNrRmxvd1BhcnRFbmRBcmdzPFRQYXJ0Pj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VyIHRoYXQgaGFuZGxlcyB0aGUgcGFydCBzdGFydCBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcnRTdGFydE1hbmFnZXI6IE9wZXJhdGlvbk1hbmFnZXI8SVRhc2tGbG93UGFydFN0YXJ0QXJnczxUUGFydD4+O1xyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQdWJsaWNcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJ0RW5kTWFuYWdlciA9IG5ldyBPcGVyYXRpb25NYW5hZ2VyPElUYXNrRmxvd1BhcnRFbmRBcmdzPFRQYXJ0Pj4oXHJcbiAgICAgICAgICAgIFRBU0tfUEFSVF9XSEVOX0VWRU5UUy5FTkQsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5wYXJ0U3RhcnRNYW5hZ2VyID0gbmV3IE9wZXJhdGlvbk1hbmFnZXI8SVRhc2tGbG93UGFydFN0YXJ0QXJnczxUUGFydD4+KFxyXG4gICAgICAgICAgICBUQVNLX1BBUlRfV0hFTl9FVkVOVFMuU1RBUlQsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIHRoZSBhY2Nlc3Mgb2YgdGhlIHBhcnQgZW5kIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgQWNjZXNzIG9mIHRoZSBwYXJ0IGVuZCBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBhcnRFbmRMaXN0ZW5lckFjY2VzcygpOiBJT3BlcmF0aW9uTWFuYWdlckFjY2VzczxJVGFza0Zsb3dQYXJ0RW5kQXJnczxUUGFydD4+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKFxyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IChldmVudEFyZ3M6IElUYXNrRmxvd1BhcnRFbmRBcmdzPFRQYXJ0PikgPT4gdm9pZCxcclxuICAgICAgICAgICAgKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnBhcnRFbmRNYW5hZ2VyLnN1YnNjcmliZShhbGlhcywgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbihhbGlhczogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5wYXJ0RW5kTWFuYWdlci51bnN1YnNjcmliZShhbGlhcywgaW5kZXgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIHRoZSBhY2Nlc3Mgb2YgdGhlIHBhcnQgc3RhcnQgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyBBY2Nlc3Mgb2YgdGhlIHBhcnQgc3RhcnQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQYXJ0U3RhcnRMaXN0ZW5lckFjY2VzcygpOiBJT3BlcmF0aW9uTWFuYWdlckFjY2VzczxJVGFza0Zsb3dQYXJ0U3RhcnRBcmdzPFRQYXJ0Pj4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24oXHJcbiAgICAgICAgICAgICAgICBhbGlhczogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogKGV2ZW50QXJnczogSVRhc2tGbG93UGFydFN0YXJ0QXJnczxUUGFydD4pID0+IHZvaWQsXHJcbiAgICAgICAgICAgICk6IG51bWJlciB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5wYXJ0U3RhcnRNYW5hZ2VyLnN1YnNjcmliZShhbGlhcywgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbihhbGlhczogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5wYXJ0U3RhcnRNYW5hZ2VyLnVuc3Vic2NyaWJlKGFsaWFzLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgYSB0YXNrIGZsb3cuXHJcbiAgICAgKiBAcGFyYW0gdGFza0Zsb3cgVGFzayBmbG93IHRvIGJlIG1hbmFnZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUYXNrIHBhcnQgcHJvbWlzZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoYW5kbGUodGFza0Zsb3c6IElUYXNrRmxvdzxUUGFydD4pOiBBcnJheTxQcm9taXNlPHZvaWQ+PiB7XHJcbiAgICAgICAgaWYgKHRhc2tGbG93ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdFxcJ3MgcmVxdWlyZWQgYSB0YXNrIGZsb3cuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXNrRmxvdy5wYXJ0cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXRcXCdzIHJlcXVpcmVkIGEgdGFzayBmbG93IHdpdGggcGFydHMuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRUYXNrID0gdGFza0Zsb3c7XHJcbiAgICAgICAgY29uc3QgcGFydFByb21pc2VzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IG5ldyBBcnJheSh0YXNrRmxvdy5wYXJ0cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhc2tGbG93LnBhcnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHBhcnRQcm9taXNlc1tpXSA9IHRoaXMuaGFuZGxlVGFza1BhcnQodGFza0Zsb3cucGFydHNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnRQcm9taXNlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgYSB0YXNrIHBhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcnQgVGFzayBwYXJ0IHRvIGhhbmRsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIHBhcnQgb2YgdGhlIHRhc2sgaXMgZmluaXNoZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBoYW5kbGVUYXNrUGFydChwYXJ0OiBUUGFydCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuaGFuZGxlVGFza1BhcnRXaGVuKHBhcnQud2hlbikudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIDEuIEVtaXQgdGhlIHN0YXJ0IG9mIHRhc2sgcGFydC5cclxuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRFbWl0dGVyLmVtaXQoXHJcbiAgICAgICAgICAgICAgICAgICAgVEFTS19QQVJUX1dIRU5fRVZFTlRTLlNUQVJULFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXNlczogW3BhcnQuYWxpYXNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgSVRhc2tGbG93UGFydFN0YXJ0QXJnczxUUGFydD4sXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2U6IFByb21pc2VMaWtlPHt9IHwgdm9pZD4gPSB0aGF0LnBlcmZvcm1UYXNrKHBhcnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAzLiBFbWl0IHRoZSBlbmQgb2YgdGhlIHRhc2sgcGFydCBhbmQgcmVzb2x2ZSB0aGUgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmV2ZW50RW1pdHRlci5lbWl0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUQVNLX1BBUlRfV0hFTl9FVkVOVFMuRU5ELFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBbcGFydC5hbGlhc10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIElUYXNrRmxvd1BhcnRFbmRBcmdzPFRQYXJ0PixcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnI6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSB0YXNrIHBhcnQuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBUYXNrIHBhcnQgdG8gYmUgcGVyZm9ybWVkLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSBwYXJ0IHRhc2sgaXMgcGVyZm9ybWVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcGVyZm9ybVRhc2socGFydDogVFBhcnQpOiBQcm9taXNlTGlrZTx7fSB8IHZvaWQ+O1xyXG5cclxuICAgIC8vI3JlZ2lvbiBUYXNrUGFydFdoZW5jb25zdHJhaW50XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSB3aGVuIGVudGl0eSBvZiBhIHRhc2sgcGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2hlbkVudGl0eSBXaGVuIGVudGl0eSB0byBoYW5kbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSB3aGVuIGVudGl0eSBpcyBjaGVja2VkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlVGFza1BhcnRXaGVuKHdoZW5FbnRpdHk6IElUYXNrUGFydFdoZW5Db25zdHJhaW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSB3aGVuRW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHdoZW5FbnRpdHkuY29uc3RyYWludFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRBU0tfQ09OU1RSQUlOVF9UWVBFUy5TVEFSVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVUYXNrUGFydFdoZW5QYXJ0QmVnaW5zKHdoZW5FbnRpdHkgYXMgVGFza1BhcnRCZWdpbkNvbnN0cmFpbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUQVNLX0NPTlNUUkFJTlRfVFlQRVMuRU5EOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlblBhcnRFbmRzKHdoZW5FbnRpdHkgYXMgVGFza1BhcnRFbmRDb25zdHJhaW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEFTS19DT05TVFJBSU5UX1RZUEVTLkdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlblBhcnRHcm91cCh3aGVuRW50aXR5IGFzIFRhc2tHcm91cENvbnN0cmFpbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUQVNLX0NPTlNUUkFJTlRfVFlQRVMuV0FJVF9GT1I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlVGFza1BhcnRXaGVuV2FpdEZvcih3aGVuRW50aXR5IGFzIFRhc2tUaW1lQ29uc3RyYWludClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVbmV4cGVjdGVkIHdoZW4gZW50aXR5IHR5cGUuJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSB3aGVuIGVudGl0eSAoVGFza1BhcnRCZWdpbkNvbnN0cmFpbnQpIG9mIGEgdGFzayBwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aGVuRW50aXR5IFdoZW4gZW50aXR5IHRvIGhhbmRsZS5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgd2hlbiBlbnRpdHkgaXMgY2hlY2tlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZVRhc2tQYXJ0V2hlblBhcnRCZWdpbnMod2hlbkVudGl0eTogVGFza1BhcnRCZWdpbkNvbnN0cmFpbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJ0U3RhcnRNYW5hZ2VyLnVuc3Vic2NyaWJlKHdoZW5FbnRpdHkuYWxpYXMsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsID09IHdoZW5FbnRpdHkuYWZ0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlVGFza1BhcnRXaGVuKHdoZW5FbnRpdHkuYWZ0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbjogbnVtYmVyID0gdGhhdC5wYXJ0U3RhcnRNYW5hZ2VyLnN1YnNjcmliZSh3aGVuRW50aXR5LmFsaWFzLCBldmVudEhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB0aGUgd2hlbiBlbnRpdHkgKFRhc2tQYXJ0RW5kQ29uc3RyYWludCkgb2YgYSB0YXNrIHBhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdoZW5FbnRpdHkgV2hlbiBlbnRpdHkgdG8gaGFuZGxlLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSB3aGVuIGVudGl0eSBpcyBjaGVja2VkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlVGFza1BhcnRXaGVuUGFydEVuZHMod2hlbkVudGl0eTogVGFza1BhcnRFbmRDb25zdHJhaW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQucGFydEVuZE1hbmFnZXIudW5zdWJzY3JpYmUod2hlbkVudGl0eS5hbGlhcywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gd2hlbkVudGl0eS5hZnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVUYXNrUGFydFdoZW4od2hlbkVudGl0eS5hZnRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuOiBudW1iZXIgPSB0aGF0LnBhcnRFbmRNYW5hZ2VyLnN1YnNjcmliZSh3aGVuRW50aXR5LmFsaWFzLCBldmVudEhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB0aGUgd2hlbiBlbnRpdHkgKFRhc2tHcm91cENvbnN0cmFpbnQpIG9mIGEgdGFzayBwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aGVuRW50aXR5IFdoZW4gZW50aXR5IHRvIGhhbmRsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIHdoZW4gZW50aXR5IGlzIGNoZWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBoYW5kbGVUYXNrUGFydFdoZW5QYXJ0R3JvdXAod2hlbkVudGl0eTogVGFza0dyb3VwQ29uc3RyYWludCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRQcm9taXNlczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBuZXcgQXJyYXkod2hlbkVudGl0eS5jb25zdHJhaW50cy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aGVuRW50aXR5LmNvbnN0cmFpbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFByb21pc2VzW2ldID0gbmV3IFByb21pc2U8dm9pZD4oZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVUYXNrUGFydFdoZW4od2hlbkVudGl0eS5jb25zdHJhaW50c1tpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFRhc2tQYXJ0V2hlbk9wZXJhdG9yLkFORCA9PT0gd2hlbkVudGl0eS5vcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY2hpbGRQcm9taXNlcylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFRhc2tQYXJ0V2hlbk9wZXJhdG9yLk9SID09PSB3aGVuRW50aXR5Lm9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJhY2UoY2hpbGRQcm9taXNlcylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCdVbmV4cGVjdGVkIG9wZXJhdG9yLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSB3aGVuIGVudGl0eSAoVGFza1RpbWVDb25zdHJhaW50KSBvZiBhIHRhc2sgcGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2hlbkVudGl0eSBXaGVuIGVudGl0eSB0byBoYW5kbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSB3aGVuIGVudGl0eSBpcyBjaGVja2VkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlVGFza1BhcnRXaGVuV2FpdEZvcih3aGVuRW50aXR5OiBUYXNrVGltZUNvbnN0cmFpbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2hlbkVudGl0eS5hZnRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlbih3aGVuRW50aXR5LmFmdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgd2hlbkVudGl0eS5taWxsaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG59XHJcbiIsIi8qKlxyXG4gKiBQcmVmaXhlcyB1c2VkIHRvIGdhbmVyYXRlIGFsaWFzIGZvciBldmVudHMgb3ZlciB0YXNrIHBhcnRzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRBU0tfUEFSVF9XSEVOX0VWRU5UUyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUHJlZml4IGZvciBhbnkgZXZlbnQgcmFpc2VkIG9uY2UgYSB0YXNrIHBhcnQgaXMgZW5kZWQuXHJcbiAgICAgKi9cclxuICAgIEVORDogJ3BhcnQuZW5kJyxcclxuICAgIC8qKlxyXG4gICAgICogUHJlZml4IGZvciBhbnkgZXZlbnQgcmFpc2VkIG9uY2UgYSB0YXNrIHBhcnQgaXMgc3RhcnRlZC5cclxuICAgICAqL1xyXG4gICAgU1RBUlQ6ICdwYXJ0LnN0YXJ0JyxcclxufTtcclxuIiwiLyoqXHJcbiAqIExvZ2ljYWwgb3BlcmF0b3IgdG8gYXBwbHkuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBUYXNrUGFydFdoZW5PcGVyYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIEFuZCBvcGVyYXRvci5cclxuICAgICAqL1xyXG4gICAgQU5ELFxyXG4gICAgLyoqXHJcbiAgICAgKiBPciBvcGVyYXRvci5cclxuICAgICAqL1xyXG4gICAgT1IsXHJcbn1cclxuIiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgZGVmYXVsdDogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iXX0="}